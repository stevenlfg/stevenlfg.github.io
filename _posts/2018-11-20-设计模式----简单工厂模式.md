-----------


----------------

![简单工厂.png-3.3kB][1]
## 定义 ##

专门定义类(工厂类)来负责创建其他类的实例。可以根据创建方法的参数来返回不同类的实例，被创建的实例通常都具有共同的父类。

简单工厂模式中定义一个抽象类，抽象类中声明公共的特征及属性，抽象子类继承自抽象类，去实现具体的操作。工厂类根据外界需求，在工厂类中创建对应的抽象子类实例并传给外界，而对象的创建是由外界决定的。外界只需要知道抽象子类对应的参数即可，而不需要知道抽象子类的创建过程，在外界使用时甚至不用引入抽象子类。

简单工厂模式将抽象子类的创建，和关于抽象子类相关的业务逻辑分离，降低对象间的耦合度。由于工厂类只是为外界创建对象，所以并不需要实例化工厂类对象，只需要为外界提供类方法即可。外界需要什么类型的抽象子类，只需要传递对应的参数即可。外界不需要知道具体的抽象子类，只需要使用抽象类即可。

简单工厂模式主要包含三部分：

工厂类：根据外界的需求，决定创建并返回哪个具体的抽象子类。

抽象类：定义抽象子类所需的属性和方法，子类通过继承自抽象类获得这些方法。

抽象子类：继承自抽象类，是具体操作的实现者，根据需求重写父类继承过来的方法。

## 业务场景 ##

简单工厂模式主要适用于抽象子类的业务逻辑相同，但具体实现不同的情况。不同的操作子类执行同样的方法，最后的结果却是不同的，这也是多态的一种表现方式。

## 优点 ##	

1.使用者只需要给工厂类传入一个正确的约定好的参数，就可以获取你所需要的对象，而不需要知道其创建细节，一定程度上减少系统的耦合；

2.客户端无需知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，减少开发者的记忆成本；

## 缺点 ##

1.如果业务上添加新产品的话，就需要修改工厂类原有的判断逻辑，这其实是违背了开闭原则的；

2.在产品类型较多时，有可能造成工厂逻辑过于复杂。所以简单工厂模式比较适合产品种类比较少而且增多的概率很低的情况；

## 代码举例 ##


    +(Cola *)createColaWithType:(NSInteger)type{
    switch (type) {
        case 0:
            return [CocaCola new];
            break; 
        case 1:
            return [PesiCola new];
            break;
        default:
            return nil;
            break;
    }
}

    Cola *cocaCola = [SimpleFactory createColaWithType:0];
    Cola *pesiCola = [SimpleFactory createColaWithType:1];

  [1]: http://static.zybuluo.com/stevenlfg/p7tcq5qv1ycwo1uval29n9r6/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.png
