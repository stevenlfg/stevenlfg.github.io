-----------

----------------

![工厂方法.png-2.9kB][1]

## 定义 ##

又称为工厂模式，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，即通过不同的工厂子类来创建不同的产品对象；

工厂方法模式和简单工厂模式十分类似，大致结构是基本类似的。不同在于工厂方法模式对工厂类进行了进一步的抽象，将之前的一个工厂类抽象成了抽象工厂和工厂子类，抽象工厂定义一个创建抽象子类的接口，抽象工厂的子类实现这些接口并决定实例化哪个抽象子类。工厂子类决定着创建哪个抽象子类，外界决定着创建哪种工厂子类，抽象子类和工厂子类是一一对应的。

在工厂方法模式中，和简单工厂模式一样，对外隐藏了抽象子类的创建过程，外界只需要关心工厂类即可，负责实例化的工厂子类决定着最后的结果。


工厂方法模式主要包含四部分：

工厂抽象类：定义创建抽象子类的接口，通过接口返回具体的抽象子类。

工厂子类：继承自工厂抽象类，并重写父类的方法来创建对应的抽象子类。

抽象类：定义抽象子类所需的属性和方法，子类通过继承自抽象类获得这些方法。

抽象子类：继承自抽象类，实现具体的操作。


为什么要用工厂方法模式？

在简单工厂模式的代码中，如果我们没有使用反射机制，只是标准的简单工厂模式代码。会有一个问题，就是如果新增加其他运算功能，需要创建一个抽象子类，但是还需要修改工厂类中的代码逻辑，这种设计是不符合开放封闭原则的。开放封闭原则对于修改是关闭的，对于扩展是开放的。而且将所有的操作子类的判断和实例化都由一个工厂类完成，如果业务比较复杂会导致工厂类负担较重。

工厂方法模式将之前负责生成具体抽象子类的工厂类，抽象为工厂抽象类和工厂子类组成的一系列类。每创建一个抽象子类，就需要创建一个工厂子类，并且一一对应，由工厂子类去生成对应的抽象子类，由外界使用方来决定生成哪个工厂子类。这样在增加新的需求时，就不需要对工厂抽象类进行修改，而是对应新增的抽象子类创建对应的工厂子类即可。


## 举例 ##

工厂方法和简单工厂有一些区别，简单工厂是由一个代工厂生产不同的产品，而工厂方法是对工厂进行抽象化，不同产品都由专门的具体工厂来生产。可口可乐工厂专门生产可口可乐，百事可乐工厂专门生产百事可乐。

## 优点 ##
1.用户只需要关心其所需产品对应的具体工厂是哪一个即可，不需要关心产品的创建细节，也不需要知道具体产品类的类名；

2.当系统中加入新产品时，不需要修改抽象工厂和抽象产品提供的接口，也无需修改客户端和其他的具体工厂和具体产品，而只要添加一个具体工厂和与其对应的具体产品就可以了，符合了开闭原则；

## 缺点 ##
当系统中加入新产品时，除了需要提供新的产品类之外，还要提供与其对应的具体工厂类。因此系统中类的个数将成对增加，增加了系统的复杂度；


## 代码举例 ##

    +(Cola*)createCola{
    return [Cola new];
    }
    
    +(Box*)createBox{
    return [Box new];
    }
    
    +(Bottle *)createBottle{
    return [Bottle new];
    }
    
    Cola *pesiCola = [PesiColaFactory createCola];
    Cola *cocaCola = [CocaColaFactory createCola];




[1]: http://static.zybuluo.com/stevenlfg/fu9wdb2gzx5qefwjfq10e54v/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.png
